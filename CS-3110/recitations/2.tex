\subsection*{Recitation 2}

\begin{itemize}
    \item Need to cover some minor features we may have missed, some details on evaluation and substitution model
    \item Note for below: we use \texttt{def ::= \textit{(* definition *)}} to make a definition, \texttt{def := <type>} to specify its type
    \item Some infix binary operators we missed:
    \begin{enumerate}
        \item Exponentiation: \texttt{** := float -> float -> float} (can customize a function to extend to \texttt{int}s as well)
        \item Logical \texttt{and}: \texttt{\&\& := boolean -> boolean -> boolean}
        \begin{itemize}
            \item In \texttt{a \&\& b}, if \texttt{a} is \texttt{false}, then \texttt{a \&\& b} short-circuits to \texttt{false}
        \end{itemize}
        \item Logical \texttt{or}: \texttt{|| := boolean -> boolean -> boolean}
        \begin{itemize}
            \item In \texttt{c || d}, if \texttt{c} is \texttt{true}, then \texttt{c || d} short-circuits to \texttt{true}
        \end{itemize}
        \item Bitwise \texttt{and}: \texttt{land := int -> int -> int}
        \item Bitwise \texttt{or}: \texttt{lor := int -> int -> int}
        \item Bitwise \texttt{xor}: \texttt{lxor := int -> int -> int}
        \item Bitwise \texttt{not}: \texttt{lnot := int -> int}
        \begin{itemize}
            \item This is included for completion; it is actually a unary prefix operator
        \end{itemize}
        \item Logical left shift: \texttt{lsl := int -> int -> int}
        \begin{itemize}
            \item The arithmetic left shift is the same as the logical one (see CS 3410 notes for more on digital logic)
        \end{itemize}
        \item Logical right shift: \texttt{lsr := int -> int -> int}
        \item Arithmetic right shift: \texttt{asr := int -> int -> int}
    \end{enumerate}
    \item Distinction between \textit{true equality} and \textit{Leibniz equality}: Former refers to same mathematical object while latter refers to structural equality, i.e. two objects are indiscernable property-wise but are distinct in allocation
    \item In practice: true equality is equality of memory address, while structural equailty is equality of properties/fields
    \item \textsf{OCaml}: There are separate equal/unequal operators for checking true vs. structural equality (\textsf{Java}-esque)
    \begin{itemize}
        \item True equality: \texttt{==} (equal), \texttt{!=} (unequal)
        \item Structural equality: \texttt{=} (equal), \texttt{<>} (unequal)
    \end{itemize}
    \item The other thing we missed were some simple floating-point mathematical functions that make life easier:
    \begin{enumerate}
        \item Absolute value: \texttt{abs := float -> float}
        \item Arc-cosine: \texttt{acos := float -> float}
        \item Arc-sine: \texttt{asin := float -> float}
        \item Arc-tangent: \texttt{atan := float -> float}
        \item Cosine: \texttt{cos := float -> float}
        \item Hyperbolic cosine: \texttt{cosh := float -> float}
        \item Exponential ($e$): \texttt{exp := float -> float}
        \item Natural logarithm: \texttt{log := float -> float}
        \item Common logarithm: \texttt{log10 := float -> float}
        \item Sine: \texttt{sin := float -> float}
        \item Hyperbolic sine: \texttt{sinh := float -> float}
        \item Square root: \texttt{sqrt := float -> float}
        \item Tangent: \texttt{tan := float -> float}
        \item Hyperbolic tangent: \texttt{tanh := float -> float}
    \end{enumerate}
    \item Challenge: Use math skills to derive all other needed functions and implement them into your own library
    \item Now to explore the \textit{substitution model} we've been using all along in our evaluations
    \item Quick notation simplification before we start using it: \texttt{e\{v/x\}} means ``evaluate \texttt{e} with \texttt{v} plugged in for \texttt{x}", or more precisely ``\lstinline{let x = v in e}" (this is the better intuition for evaluation)
    \item A quick example of how we evaluated using small-step semantics in our substitution model:
    \begin{lstlisting}
    let x = 3 in (x + x) --> (3 + 3) --> 6
    \end{lstlisting}
    \item There are generalized rules we must use, in case expressions themselves define new variables:
    \begin{enumerate}
        \item \texttt{n\{v'/x\} ::= n}
        \item \texttt{x\{v/x\} ::= v}
        \item \texttt{y\{v/x\} ::= y} if \texttt{y} is not equal to \texttt{x} (equality becomes Case 2)
        \item \texttt{(e1 op e2) \{v/x\} ::= e1\{v/x\} op e2\{v/x\}}
        \item \texttt{(let x = e1 in e2) \{v/x\} ::= let x = e1\{v/x\} in e2}
        \item \texttt{(let y = e1 in e2) \{v/x\} ::= let y = e1\{v/x\} in e2\{v/x\}} if \texttt{x} is not equal to \texttt{y}
    \end{enumerate}
    \item Let's move onto \textsf{OCaml} evaluation; recall that every \textsf{OCaml} program is an expression
    \item A
\end{itemize}
